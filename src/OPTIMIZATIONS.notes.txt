could change basic calling coupling to be ZAMValUnion-based
	- helps if compiler supports "when" and lambdas, so that *everything*
	  can be inlined/compiled

could figure out that a given function is potentially the target of an
indirect call and generate a ZAM body for it in case that happens

could omit some load-globals if there's not been a call since the last one

implement /foo/ !in x && /bar/ !in x ... cascade analogous to current one

need to hook into notifier::Modifiable framework for aggregates

need to fix IterInfo's to be (1) dynamic, via (2) IntrusivePtr's

hoist loop invariants

unroll loops

suppress sync-globals that are straight-line code from previous ones
	for which no global was modified

collapse dirty-global-V <x> / load-global-VC <x> sequences

can remove Store-Any-Val

don't consider modifying a global's element as a reaching-def for
	the global itself (glb[5] = 3)

don't bother loading unused function parameters

could explicitly support +=/-= for integral types

could flatten tail-recursion to enable inlining

could save grief/complexity by splitting out early (in the parser)
	operands with weird mixed types, like DivideExpr supporting
	address masking, or InExpr supporting patterns/strings.
	This would allow simplifications for gen-compiler-templates.sh.

speed up vector operations that currently punt to converting to VectorVal's

