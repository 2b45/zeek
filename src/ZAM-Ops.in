# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

assign-op Assign
type X
eval @$2

unary-expr-op Clone
op-type X
set-type $1
set-type2 $2
eval auto v = frame[z.v2].ToVal(z.t2)->Clone();
eval AssignV1(BuildVal(v, z.t));

unary-expr-op Size
no-const
op-type i u d A N S T V *
type-selector 2
set-type $1
set-type2 $2
#
eval_i $$.uint_val = $1 < 0 ? -$1 : $1
#
eval_u $$.uint_val = $1
#
eval_d $$.double_val = $1 < 0 ? -$1 : $1
#
eval_A $$.uint_val = $1->AsAddr().GetFamily() == IPv4 ? 32 : 128
#
eval_N $$.double_val = pow(2.0, double(128 - $1->AsSubNet().LengthIPv6()))
#
eval_S $$.uint_val = $1->Len()
#
eval_T $$.uint_val = $1->Size()
#
eval_V $$.uint_val = $1->Size()
#
eval auto v = frame[z.v2].ToVal(z.t2)->SizeVal(); $$ = BuildVal(v, z.t);

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

op IncrI
op1-read-write
type V
eval ++frame[z.v1].int_val

op IncrU
op1-read-write
type V
eval ++frame[z.v1].uint_val

op DecrI
op1-read-write
type V
eval --frame[z.v1].int_val

op DecrU
op1-read-write
type V
eval --frame[z.v1].uint_val

unary-op AppendTo
# Note, even though it feels like appending both reads and modifies
# its first operand, for our purposes it just reads it (to get the
# aggregate), and then modifies its *content* but not the operand's
# value itself.
op1-read
set-type $2
eval auto copy = CopyVal($1)
eval auto& vv = frame[z.v1].vector_val->RawVector()->ModVec()
eval vv.push_back(copy)

internal-op AppendToField
type VVi
op1-read
eval auto v = CopyVal(frame[z.v2])
eval auto fvv = frame[z.v1].record_val->RawFields()->Lookup(z.v3, ZAM_error)
eval if ( ZAM_error ) ZAM_run_time_error(z.loc, fmt("field value missing: $%s", frame[z.v1].record_val->Type()->AsRecordType()->FieldName(z.v3)))
eval else fvv.vector_val->RawVector()->ModVec().push_back(v)

internal-op AppendToField
type VCi
op1-read
eval auto v = CopyVal(z.c)
eval auto fvv = frame[z.v1].record_val->RawFields()->Lookup(z.v2, ZAM_error)
eval if ( ZAM_error ) ZAM_run_time_error(z.loc, fmt("field value missing: $%s", frame[z.v1].record_val->Type()->AsRecordType()->FieldName(z.v2)))
eval else fvv.vector_val->RawVector()->ModVec().push_back(v)

unary-expr-op Cast
op-type X
set-type $1
set-type2 $2
eval const char* error;
eval auto rhs = frame[z.v2].ToVal(z.t2).get();
eval auto res = cast_value(rhs, z.t.get(), error);
eval if ( error ) ZAM_run_time_error(z.loc, error);
eval else AssignV1(BuildVal(res, z.t));

# Cast an "any" type to the given type.  Only needed for type-based swith
# statements.
internal-op Cast-Any
type VV
eval const char* error
eval auto res = cast_value(frame[z.v2].any_val, z.t.get(), error)
eval if ( error ) ZAM_run_time_error(z.loc, error)
eval else AssignV1(BuildVal(res, z.t));

direct-unary-op Is Is

internal-op Is
type VV
eval auto rhs = frame[z.v2].ToVal(z.t2).get()
eval frame[z.v1].int_val = can_cast_value_to_type(rhs, z.t.get())

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1->AsString())
eval_S strings.push_back($2->AsString())
eval_S auto res = new StringVal(concatenate(strings))
eval_S Unref($$)
eval_S $$ = res

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
#
eval_T auto v = $1->Clone()
eval_T auto s = v.release()->AsTableVal()
eval_T $2->RemoveFrom(s)
eval_T Unref($$)
eval_T $$ = s

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
#
eval-pre if ( $2 == 0 ) { ZAM_run_time_error(z.loc, "division by zero"); break; }
eval $1 / $2
#
eval-mixed A I auto mask = static_cast<uint32_t>($2)
eval-mixed A I auto a = $1->AsAddr()
eval-mixed A I if ( a.GetFamily() == IPv4 && mask > 32 ) ZAM_run_time_error(z.loc, fmt("bad IPv4 subnet prefix length: %" PRIu32, mask))
eval-mixed A I if ( a.GetFamily() == IPv6 && mask > 128 ) ZAM_run_time_error(z.loc, fmt("bad IPv6 subnet prefix length: %" PRIu32, mask))
eval-mixed A I auto v = make_intrusive<SubNetVal>(a, mask)
eval-mixed A I Unref(frame[z.v1].subnet_val)
eval-mixed A I frame[z.v1].subnet_val = v.release()
eval-mixed A I /* Note, $$ is ignored but mentioned here so templator backs off */

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) { ZAM_run_time_error(z.loc, "modulo by zero"); break; }
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval $1 && $2

binary-expr-op Or-Or
op-type I
vector
eval $1 || $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
#
eval_P auto p = new PatternVal(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()))
eval_P Unref($$)
eval_P $$ = p
#
eval_T auto res = $1->Intersect($2)
eval_T Unref($$)
eval_T $$ = res

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
#
eval_P auto p = new PatternVal(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()))
eval_P Unref($$)
eval_P $$ = p
#
eval_T auto v = $1->Clone()
eval_T auto s = v.release()->AsTableVal()
eval_T (void) $2->AddTo(s, false, false)
eval_T Unref($$)
eval_T $$ = s

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) < 0
eval_T $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $1->AsAddr() < $2->AsAddr()

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) <= 0
eval_T $1->IsSubsetOf($2)
eval_A $1->AsAddr() < $2->AsAddr() || $1->AsAddr() == $2->AsAddr()

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) == 0
eval_T $1->EqualTo($2)
eval_A $1->AsAddr() == $2->AsAddr()
eval_N $1->AsSubNet() == $2->AsSubNet()
eval-mixed P S $1->AsPattern()->MatchExactly($2->AsString())

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) != 0
eval_T ! $1->EqualTo($2)
eval_A $1->AsAddr() != $2->AsAddr()
eval_N $1->AsSubNet() != $2->AsSubNet()
eval-mixed P S ! $1->AsPattern()->MatchExactly($2->AsString())

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) >= 0
eval_A ! ($1->AsAddr() < $2->AsAddr())

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) > 0
eval_A ! ($1->AsAddr() < $2->AsAddr()) && $1->AsAddr() != $2->AsAddr()

########## Nonuniform Expressions ##########

assign-op Field
type R
field-op
eval auto rv = $2.record_val->RawFields()
eval auto v = rv->Lookup(z.v3, ZAM_error)
eval if ( ZAM_error ) ZAM_run_time_error(z.loc, fmt("field value missing: $%s", $2.record_val->Type()->AsRecordType()->FieldName(z.v3)))
eval else @v

expr-op Has-Field
type Ri
eval frame[z.v1].int_val = (frame[z.v2].record_val->RawFields()->HasField(z.v3))

internal-op Has-Field-Cond
op1-read
type VVV
eval if ( ! frame[z.v1].record_val->RawFields()->HasField(z.v2) ) { pc = z.v3; continue; }

internal-op Not-Has-Field-Cond
op1-read
type VVV
eval if ( frame[z.v1].record_val->RawFields()->HasField(z.v2) ) { pc = z.v3; continue; }

expr-op In
type VVV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VVC
custom-method return CompileInExpr($*);
no-eval

internal-op P-In-S
type VVV
eval frame[z.v1].int_val = frame[z.v2].re_val->AsPattern()->MatchAnywhere(frame[z.v3].string_val->AsString()) != 0

internal-op P-In-S
type VCV
eval frame[z.v1].int_val = z.c.re_val->AsPattern()->MatchAnywhere(frame[z.v2].string_val->AsString()) != 0

internal-op P-In-S
type VVC
eval frame[z.v1].int_val = frame[z.v2].re_val->AsPattern()->MatchAnywhere(z.c.string_val->AsString()) != 0

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString())
eval auto cmp = strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc)
eval $$ = cmp != -1

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval $$ = op2->Contains(op1->AsAddr())


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-T
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval


internal-op Val-Is-In-Table
type VVV
# No set-type as these are internal ops.
eval auto op1 = frame[z.v2].ToVal(z.t)
eval frame[z.v1].int_val = frame[z.v3].table_val->Lookup(op1.get()) != nullptr

internal-op Val-Is-In-Table-Cond
op1-read
type VVV
eval auto op1 = frame[z.v1].ToVal(z.t)
eval if ( ! frame[z.v2].table_val->Lookup(op1.get()) ) { pc = z.v3; continue; }

internal-op Val-Is-Not-In-Table-Cond
op1-read
type VVV
eval auto op1 = frame[z.v1].ToVal(z.t)
eval if ( frame[z.v2].table_val->Lookup(op1.get()) ) { pc = z.v3; continue; }

# Variants for indexing two values, one of which might be a constant.
# We set the instructions's *second* type to be that of the first variable
# index.  We get the type of the second variable (if any) by digging it
# out of the table's type.  For a constant in either position, we use
# the main instruction type, as always.

internal-op Val2-Is-In-Table
type VVVV
eval auto& tt_ind = *frame[z.v4].table_val->Type()->AsTableType()->IndexTypes()
eval auto op1 = frame[z.v2].ToVal(z.t2)
eval auto op2 = frame[z.v3].ToVal({NewRef{}, tt_ind[1]})
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval frame[z.v1].int_val = frame[z.v4].table_val->Lookup(&lv) != nullptr

internal-op Val2-Is-In-Table-Cond
op1-read
type VVVV
eval auto& tt_ind = *frame[z.v3].table_val->Type()->AsTableType()->IndexTypes()
eval auto op1 = frame[z.v1].ToVal(z.t2)
eval auto op2 = frame[z.v2].ToVal({NewRef{}, tt_ind[1]})
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( ! frame[z.v3].table_val->Lookup(&lv) ) { pc = z.v4; continue; }

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVVV
eval auto& tt_ind = *frame[z.v3].table_val->Type()->AsTableType()->IndexTypes()
eval auto op1 = frame[z.v1].ToVal(z.t2)
eval auto op2 = frame[z.v2].ToVal({NewRef{}, tt_ind[1]})
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( frame[z.v3].table_val->Lookup(&lv) ) { pc = z.v4; continue; }

internal-op Val2-Is-In-Table
type VVVC
eval auto op1 = frame[z.v2].ToVal(z.t2)
eval auto op2 = z.c.ToVal(z.t)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval frame[z.v1].int_val = frame[z.v3].table_val->Lookup(&lv) != nullptr

internal-op Val2-Is-In-Table-Cond
op1-read
type VVVC
eval auto op1 = frame[z.v1].ToVal(z.t2)
eval auto op2 = z.c.ToVal(z.t)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( ! frame[z.v2].table_val->Lookup(&lv) ) { pc = z.v3; continue; }

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVVC
eval auto op1 = frame[z.v1].ToVal(z.t2)
eval auto op2 = z.c.ToVal(z.t)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( frame[z.v2].table_val->Lookup(&lv) ) { pc = z.v3; continue; }

internal-op Val2-Is-In-Table
type VVCV
eval auto op1 = z.c.ToVal(z.t)
eval auto op2 = frame[z.v2].ToVal(z.t2)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval frame[z.v1].int_val = frame[z.v3].table_val->Lookup(&lv) != nullptr

internal-op Val2-Is-In-Table-Cond
op1-read
type VVCV
eval auto op1 = z.c.ToVal(z.t)
eval auto op2 = frame[z.v1].ToVal(z.t2)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( ! frame[z.v2].table_val->Lookup(&lv) ) { pc = z.v3; continue; }

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVCV
eval auto op1 = z.c.ToVal(z.t)
eval auto op2 = frame[z.v1].ToVal(z.t2)
eval ListVal lv(TYPE_ANY)
eval lv.Append(op1.release())
eval lv.Append(op2.release())
eval if ( frame[z.v2].table_val->Lookup(&lv) ) { pc = z.v3; continue; }


internal-op Const-Is-In-Table
type VCV
eval auto op1 = z.c.ToVal(z.t)
eval frame[z.v1].int_val = frame[z.v2].table_val->Lookup(op1.get()) != nullptr

internal-op Const-Is-In-Table-Cond
op1-read
type VVC
eval auto op1 = z.c.ToVal(z.t)
eval if ( ! frame[z.v1].table_val->Lookup(op1.get()) ) { pc = z.v2; continue; }

internal-op Const-Is-Not-In-Table-Cond
op1-read
type VVC
eval auto op1 = z.c.ToVal(z.t)
eval if ( frame[z.v1].table_val->Lookup(op1.get()) ) { pc = z.v2; continue; }

internal-op List-Is-In-Table
type VV
eval auto op1 = z.aux->ToListVal(frame)
eval frame[z.v1].int_val = frame[z.v2].table_val->Lookup(op1.get()) != nullptr

internal-op List-Is-In-Table
type VC
eval auto op1 = z.aux->ToListVal(frame)
eval frame[z.v1].int_val = z.c.table_val->Lookup(op1.get()) != nullptr

internal-op Val-Is-In-Vector
type VVV
eval auto& vec = frame[z.v3].vector_val
eval auto ind = frame[z.v2].int_val
eval frame[z.v1].int_val = ind >= 0 && ind < vec->Size()

internal-op Const-Is-In-Vector
type VCV
eval auto& vec = frame[z.v2].vector_val
eval auto ind = z.c.int_val
eval frame[z.v1].int_val = ind >= 0 && ind < vec->Size()

internal-op Index-Is-In-Vector
type VV
eval auto op1 = z.aux->ToListVal(frame)
eval auto op2 = frame[z.v2].vector_val
eval frame[z.v1].int_val = op2->Lookup(op1.get()) != nullptr

internal-op Index-Is-In-Vector
type VC
eval auto op1 = z.aux->ToListVal(frame)
eval auto op2 = z.c.vector_val
eval frame[z.v1].int_val = op2->Lookup(op1.get()) != nullptr

expr-op Cond
type VVVV
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(frame[z.v4]))

expr-op Cond
type VVVC
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(z.c))

expr-op Cond
type VVCV
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(z.c) : CopyVal(frame[z.v3]))

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
set-type $1
eval if ( frame[z.v2].int_val ) AssignV1(CopyVal(z.c))

op CondC2
set-type $1
type VVC
eval if ( ! frame[z.v2].int_val ) AssignV1(CopyVal(z.c))

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
eval if ( frame[z.v2].vector_val->Size() != frame[z.v3].vector_val->Size() ) {
eval	ZAM_run_time_error(z.loc, "size mismatch, boolean index and vector")
eval	break; }
eval auto vt = z.t->AsVectorType()
eval auto v2 = frame[z.v2].vector_val
eval auto v3 = frame[z.v3].vector_val
eval auto v = vector_bool_select(vt, v2, v3)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = v.release()

op IndexVecBoolSelect
type VCV
set-type $1
eval if ( z.c.vector_val->Size() != frame[z.v2].vector_val->Size() ) {
eval	ZAM_run_time_error(z.loc, "size mismatch, boolean index and vector")
eval	break; }
eval auto vt = z.t->AsVectorType()
eval auto v2 = z.c.vector_val
eval auto v3 = frame[z.v2].vector_val
eval auto v = vector_bool_select(vt, v2, v3)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = v.release()

op IndexVecIntSelect
type VVV
set-type $1
eval auto vt = z.t->AsVectorType()
eval auto v2 = frame[z.v2].vector_val
eval auto v3 = frame[z.v3].vector_val
eval auto v = vector_int_select(vt, v2, v3)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = v.release()

op IndexVecIntSelect
type VCV
set-type $1
eval auto vt = z.t->AsVectorType()
eval auto v2 = z.c.vector_val
eval auto v3 = frame[z.v2].vector_val
eval auto v = vector_int_select(vt, v2, v3)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = v.release()

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

op Index
type VCL
custom-method return CompileIndex(n, c, l);

internal-op Index-Vec
type VVV
eval auto vv = frame[z.v2].vector_val->RawVector()
eval auto& vec = vv->ConstVec()
eval auto ind = frame[z.v3].uint_val
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.loc, "no such index")
eval AssignV1(CopyVal(vec[ind]))

internal-op Index-Any-Vec
type VVV
eval auto vv = frame[z.v2].vector_val->RawVector()
eval auto& vec = vv->ConstVec()
eval auto ind = frame[z.v3].uint_val
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.loc, "no such index")
eval auto v = vec[ind].ToVal(vv->YieldType())
eval Unref(frame[z.v1].any_val)
eval frame[z.v1].any_val = v.release()

internal-op Index-VecC
type VVV
eval auto vv = frame[z.v2].vector_val->RawVector()
eval auto& vec = vv->ConstVec()
eval unsigned int ind = z.v3
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.loc, "no such index")
eval AssignV1(CopyVal(vec[ind]))

internal-op Index-Any-VecC
type VVV
eval auto vv = frame[z.v2].vector_val->RawVector()
eval auto& vec = vv->ConstVec()
eval unsigned int ind = z.v3
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.loc, "no such index")
eval auto v = vec[ind].ToVal(vv->YieldType())
eval Unref(frame[z.v1].any_val)
eval frame[z.v1].any_val = v.release()

internal-op Index-Vec-Slice
type VV
eval auto vt = z.t->AsVectorType()
eval auto vec = frame[z.v2].vector_val
eval auto lv = z.aux->ToListVal(frame)
eval auto v = vector_index(vt, vec, lv.get())
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = v.release()

internal-op Table-Index
type VV
eval auto v2 = z.aux->ToListVal(frame)
eval auto v = frame[z.v2].table_val->Lookup(v2.get())
eval if ( ! v ) ZAM_run_time_error(z.loc, "no such index")
eval AssignV1(BuildVal(v, z.t))

internal-assignment-op Table-Index1
type VVV
eval auto v2 = frame[z.v3].ToVal(z.t)
eval auto v_ptr = frame[z.v2].table_val->Lookup(v2.get())
eval auto v = v_ptr.get()
eval if ( ! v ) ZAM_run_time_error(z.loc, "no such index")
eval @v

internal-assignment-op Table-Index1
type VVC
eval auto v2 = z.c.ToVal(z.t)
eval auto v_ptr = frame[z.v2].table_val->Lookup(v2.get())
eval auto v = v_ptr.get()
eval if ( ! v ) ZAM_run_time_error(z.loc, "no such index")
eval @v

# This version is for a variable v3.
internal-op Index-String
type VVV
eval auto str = frame[z.v2].string_val->AsString()
eval auto len = str->Len()
eval auto idx = frame[z.v3].int_val
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(v ? v : new BroString(""))

# This version is for a constant v3.
internal-op Index-StringC
type VVV
eval auto str = frame[z.v2].string_val->AsString()
eval auto len = str->Len()
eval auto idx = z.v3
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(v ? v : new BroString(""))

internal-op Index-String-Slice
type VV
eval auto str = frame[z.v2].string_val->AsString()
eval auto lv = z.aux->ToListVal(frame)
eval auto slice = index_string_slice(str, lv.get())
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(slice)

op AnyIndex
type VVi
set-type $1
eval auto lv = frame[z.v2].any_val->AsListVal()
eval if ( z.v3 < 0 || z.v3 >= lv->Length() ) reporter->InternalError("bad \"any\" element index");
eval IntrusivePtr<Val> elem = {NewRef{}, lv->Index(z.v3)}
eval if ( CheckAnyType(elem->Type(), z.t.get(), z.loc) ) {
eval	AssignV1(BuildVal(elem, z.t))
eval } else ZAM_error = true


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor ConstructTable

internal-op Construct-Table
type VV
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()};
eval IntrusivePtr<Attributes> attrs = {NewRef{}, z.attrs};
eval auto new_t = new TableVal(tt, attrs)
eval auto aux = z.aux
eval auto n = aux->n
eval auto ind_width = z.v2
eval for ( auto i = 0; i < n; ++i ) {
eval	auto indices = aux->ToIndices(frame, i, ind_width)
eval	auto v = aux->ToVal(frame, i + ind_width)
eval	new_t->Assign(indices.get(), v)
eval	i += ind_width
eval }
eval auto& t = frame[z.v1].table_val
eval Unref(t)
eval t = new_t

direct-unary-op Set-Constructor ConstructSet

internal-op Construct-Set
type VV
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()};
eval IntrusivePtr<Attributes> attrs = {NewRef{}, z.attrs};
eval auto new_s = new TableVal(tt, attrs)
eval auto aux = z.aux
eval auto n = aux->n
eval auto ind_width = z.v2
eval for ( auto i = 0; i < n; i += ind_width ) {
eval	auto indices = aux->ToIndices(frame, i, ind_width)
eval	new_s->Assign(indices.get(), nullptr)
eval }
eval auto& s = frame[z.v1].table_val
eval Unref(s)
eval s = new_s

direct-unary-op Record-Constructor ConstructRecord

internal-op Construct-Record
type V
eval auto rt = z.t->AsRecordType()
eval auto new_r = new RecordVal(rt)
eval auto aux = z.aux
eval auto n = aux->n
eval for ( auto i = 0; i < n; ++i ) new_r->Assign(i, aux->ToVal(frame, i))
eval auto& r = frame[z.v1].record_val
eval Unref(r)
eval r = new_r

internal-op Construct-Known-Record
type V
eval auto rt = z.t->AsRecordType()
eval auto new_r = new RecordVal(rt)
eval auto aux = z.aux
eval auto n = aux->n
eval auto map = aux->map
eval for ( auto i = 0; i < n; ++i ) new_r->Assign(map[i], aux->ToVal(frame, i))
eval auto& r = frame[z.v1].record_val
eval Unref(r)
eval r = new_r

direct-unary-op Vector-Constructor ConstructVector

internal-op Construct-Vector
type V
eval auto new_vv = new VectorVal(z.t->AsVectorType())
eval auto aux = z.aux
eval auto n = aux->n
eval for ( auto i = 0; i < n; ++i ) new_vv->Assign(i, aux->ToVal(frame, i))
eval auto& vv = frame[z.v1].vector_val
eval Unref(vv)
eval vv = new_vv

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval auto v = frame[z.v2].int_val
eval if ( v < 0 ) { ZAM_run_time_error(z.loc, "underflow converting int to count"); break; }
eval frame[z.v1].uint_val = bro_uint_t(v)

internal-op Coerce-UI-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_UI(frame[z.v2].vector_val)

internal-op Coerce-UD
type VV
eval auto v = frame[z.v2].double_val
eval if ( v < 0.0 ) { ZAM_run_time_error(z.loc, "underflow converting double to count"); break; }
eval if ( v > UINT64_MAX ) { ZAM_run_time_error(z.loc, "overflow converting double to count"); break; }
eval frame[z.v1].uint_val = bro_uint_t(v)

internal-op Coerce-UD-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_UD(frame[z.v2].vector_val)

internal-op Coerce-IU
type VV
eval auto v = frame[z.v2].uint_val
eval if ( v > INT64_MAX ) { ZAM_run_time_error(z.loc, "overflow converting count to int"); break; }
eval frame[z.v1].int_val = bro_int_t(v)

internal-op Coerce-IU-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_IU(frame[z.v2].vector_val)

internal-op Coerce-ID
type VV
eval auto v = frame[z.v2].double_val
eval if ( v < static_cast<double>(INT64_MIN) ) { ZAM_run_time_error(z.loc, "underflow converting double to int"); break; }
eval if ( v > static_cast<double>(INT64_MAX) ) { ZAM_run_time_error(z.loc, "overflow converting double to int"); break; }
eval frame[z.v1].int_val = bro_int_t(v)

internal-op Coerce-ID-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_ID(frame[z.v2].vector_val)

internal-op Coerce-DI
type VV
eval frame[z.v1].double_val = double(frame[z.v2].int_val)

internal-op Coerce-DI-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_DI(frame[z.v2].vector_val)

internal-op Coerce-DU
type VV
eval frame[z.v1].double_val = double(frame[z.v2].uint_val)

internal-op Coerce-DU-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_DU(frame[z.v2].vector_val)

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VV
eval auto rt = z.t->AsRecordType()
eval auto v = frame[z.v2].record_val
eval auto map = z.aux->ints
eval auto map_size = z.aux->n
eval auto to_r = coerce_to_record(rt, v, map, map_size)
eval Unref(frame[z.v1].record_val)
eval frame[z.v1].record_val = to_r.release()

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
eval auto tv = frame[z.v2].table_val
eval if ( tv->Size() > 0 ) { ZAM_run_time_error(z.loc, "coercion of non-empty table/set"); break; }
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, tv->Attrs()}
eval auto t = make_intrusive<TableVal>(tt, attrs)
eval Unref(frame[z.v1].table_val)
eval frame[z.v1].table_val = t.release()

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
eval if ( frame[z.v2].vector_val->Size() > 0 ) { ZAM_run_time_error(z.loc, "coercion of non-empty vector"); break; }
eval auto t = z.t->Ref()->AsVectorType();
eval auto vv = new VectorVal(t)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vv

unary-expr-op To-Any-Coerce
op-type X
set-type $2
eval AssignV1(ZAMValUnion(frame[z.v2].ToVal(z.t), any_base_type))

unary-expr-op From-Any-Coerce
op-type X
set-type $1
eval auto v = frame[z.v2].any_val;
eval if ( z.t->Tag() == TYPE_VECTOR ) {
eval	auto t = v->Type();
eval	if ( t->Tag() != TYPE_VECTOR ) { ZAM_run_time_error(z.loc, "RHS is not a vector"); break; }
eval	if ( ! same_type(z.t.get(), t) ) { ZAM_run_time_error(z.loc, "incompatible vectors"); break; }
eval	::Ref(v);
eval	Unref(frame[z.v1].vector_val);
eval	frame[z.v1].vector_val = v->AsVectorVal();
eval } else AssignV1(ZAMValUnion({NewRef{}, v}, z.t))


########## Aggregate Assignments ##########

op Vector-Elem-Assign
op1-read
type VVV
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val->RawVector()
eval vv->SetYieldType(z.t)
eval if ( ! vv->CopyElement(ind, frame[z.v3]) ) ZAM_run_time_error(z.loc, "value used but not set")

op Vector-Elem-Assign-Any
op1-read
type VVV
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val->RawVector()
eval vv->SetYieldType(z.t)
eval auto any_v = frame[z.v3].any_val
eval auto any_z = ZAMValUnion({NewRef{}, any_v}, {NewRef{}, any_v->Type()})
eval vv->SetElement(ind, any_z)

op Vector-Elem-Assign
op1-read
type VVC
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val->RawVector()
eval vv->SetYieldType(z.t)
eval (void) vv->CopyElement(ind, z.c)

# These versions are used when the constant is the index, not the new value.
op Vector-Elem-Assign
op1-read
type VVi
eval auto vv = frame[z.v1].vector_val->RawVector()
eval vv->SetYieldType(z.t)
eval if ( ! vv->CopyElement(z.v3, frame[z.v2]) ) ZAM_run_time_error(z.loc, "value used but not set")

op Vector-Elem-Assign-Any
op1-read
type VVi
eval auto vv = frame[z.v1].vector_val->RawVector()
eval vv->SetYieldType(z.t)
eval auto any_v = frame[z.v2].any_val
eval auto any_z = ZAMValUnion({NewRef{}, any_v}, {NewRef{}, any_v->Type()})
eval vv->SetElement(z.v3, any_z)

internal-op Vector-Slice-Assign
op1-read
type VV
eval IntrusivePtr<Val> vec = {NewRef{}, frame[z.v1].vector_val}
eval auto slice = z.aux->ToListVal(frame)
eval IntrusivePtr<Val> vals = {NewRef{}, frame[z.v2].vector_val}
eval auto error = assign_to_index(vec, slice, vals)
eval if ( error ) ZAM_run_time_error(z.loc, error)


internal-op Table-Elem-Assign
op1-read
type VV
eval auto indices = z.aux->ToListVal(frame)
eval auto val = frame[z.v2].ToVal(z.t)
eval frame[z.v1].table_val->Assign(indices.get(), val)

internal-op Table-Elem-Assign
op1-read
type VC
eval auto indices = z.aux->ToListVal(frame)
eval auto val = z.c.ToVal(z.t)
eval frame[z.v1].table_val->Assign(indices.get(), val)


assign-op Field-LHS-Assign
op1-read
type F
eval @$2
eval frame[z.v1].record_val->RawFields()->Assign($3, v)

########## Function Calls ##########

# A call with no arguments and no return value.
internal-op Call0
op1-read
type X
side-effects
eval std::vector<IntrusivePtr<Val>> args;	// empty
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# A call with no arguments and a return value.
internal-assignment-op Call0
type V
side-effects OP_CALL0_X
side-effects-op-type OP_X
eval std::vector<IntrusivePtr<Val>> args;	// empty
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

# Calls with 1 argument and no return value.
internal-op Call1
op1-read
type V
side-effects
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(frame[z.v1].ToVal(z.t))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

internal-op Call1
op1-read
type C
side-effects
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(z.c.ToVal(z.t))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same but with a return value.
internal-assignment-op Call1
type VV
side-effects OP_CALL1_V
side-effects-op-type OP_V
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(frame[z.v2].ToVal(z.t))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

internal-assignment-op Call1
type VC
side-effects OP_CALL1_C
side-effects-op-type OP_C
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(z.c.ToVal(z.t))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

# Calls with 2-5 arguments and no return value.
internal-op Call2
type X
side-effects
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same with a return value.
internal-assignment-op Call2
type V
side-effects OP_CALL2_X
side-effects-op-type OP_X
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

internal-op Call3
type X
side-effects
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same with a return value.
internal-assignment-op Call3
type V
side-effects OP_CALL3_X
side-effects-op-type OP_X
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

internal-op Call4
type X
side-effects
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval args.push_back(aux->ToVal(frame, 3))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same with a return value.
internal-assignment-op Call4
type V
side-effects OP_CALL4_X
side-effects-op-type OP_X
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval args.push_back(aux->ToVal(frame, 3))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

internal-op Call5
type X
side-effects
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval args.push_back(aux->ToVal(frame, 3))
eval args.push_back(aux->ToVal(frame, 4))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same with a return value.
internal-assignment-op Call5
type V
side-effects OP_CALL5_X
side-effects-op-type OP_X
eval auto aux = z.aux
eval std::vector<IntrusivePtr<Val>> args
eval args.push_back(aux->ToVal(frame, 0))
eval args.push_back(aux->ToVal(frame, 1))
eval args.push_back(aux->ToVal(frame, 2))
eval args.push_back(aux->ToVal(frame, 3))
eval args.push_back(aux->ToVal(frame, 4))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

# ... and with an arbitrary number of arguments.

internal-op CallN
type X
side-effects
eval auto aux = z.aux
eval auto n = aux->n
eval std::vector<IntrusivePtr<Val>> args
eval for ( auto i = 0; i < n; ++i ) args.push_back(aux->ToVal(frame, i))
eval f->SetCallLoc(z.loc)
eval (void) z.func->Call(args, f)

# Same with a return value.
internal-assignment-op CallN
type V
side-effects OP_CALLN_X
side-effects-op-type OP_X
eval auto aux = z.aux
eval auto n = aux->n
eval std::vector<IntrusivePtr<Val>> args
eval for ( auto i = 0; i < n; ++i ) args.push_back(aux->ToVal(frame, i))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = z.func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

# Same, but for indirect calls via a local variable.
internal-op IndCallN
op1-read
type V
side-effects
eval auto func = frame[z.v1].func_val
eval auto aux = z.aux
eval auto n = aux->n
eval std::vector<IntrusivePtr<Val>> args
eval for ( auto i = 0; i < n; ++i ) args.push_back(aux->ToVal(frame, i))
eval f->SetCallLoc(z.loc)
eval (void) func->Call(args, f)

# Same with a return value.
internal-assignment-op IndCallN
type VV
side-effects OP_INDCALLN_V
side-effects-op-type OP_V
eval auto func = frame[z.v2].func_val
eval auto aux = z.aux
eval auto n = aux->n
eval std::vector<IntrusivePtr<Val>> args
eval for ( auto i = 0; i < n; ++i ) args.push_back(aux->ToVal(frame, i))
eval f->SetCallLoc(z.loc)
eval auto v_ptr = func->Call(args, f)
eval if ( ! v_ptr ) { ZAM_error = true; break; }
eval auto v = v_ptr.get()
eval @v

########## Statements ##########

op Schedule
type ViHL
op1-read
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval if ( terminating ) break
eval double dt = frame[z.v1].double_val
eval if ( z.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(z.event_handler)
eval val_vec args
eval z.aux->FillValVec(args, frame)
eval auto timer = new ScheduleTimer(z.event_handler, std::move(args), dt)
eval timer_mgr->Add(timer)

op Schedule
type CiHL
op1-read
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval if ( terminating ) break
eval double dt = z.c.double_val
eval if ( z.v1 ) dt += network_time
eval auto hp = EventHandlerPtr(z.event_handler)
eval val_vec args
eval z.aux->FillValVec(args, frame)
eval auto timer = new ScheduleTimer(z.event_handler, std::move(args), dt)
eval timer_mgr->Add(timer)

internal-op Schedule0
type ViH
op1-read
eval if ( terminating ) break
eval double dt = frame[z.v1].double_val
eval if ( z.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(z.event_handler)
eval val_vec args
eval auto timer = new ScheduleTimer(z.event_handler, std::move(args), dt)
eval timer_mgr->Add(timer)

internal-op Schedule0
type CiH
op1-read
eval if ( terminating ) break
eval double dt = z.c.double_val
eval if ( z.v1 ) dt += network_time
eval auto hp = EventHandlerPtr(z.event_handler)
eval val_vec args
eval auto timer = new ScheduleTimer(z.event_handler, std::move(args), dt)
eval timer_mgr->Add(timer)


op Event
type HL
op1-read
custom-method return CompileEvent(h, l);
eval val_vec args
eval z.aux->FillValVec(args, frame)
eval mgr.Enqueue(z.event_handler, std::move(args))

internal-op Event0
type X
eval val_vec args(0)
eval mgr.Enqueue(z.event_handler, std::move(args))

internal-op Event1
type V
op1-read
eval val_vec args(1)
eval args[0] = frame[z.v1].ToVal(z.t)
eval mgr.Enqueue(z.event_handler, std::move(args))

internal-op Event2
type VV
op1-read
eval val_vec args(2)
eval args[0] = frame[z.v1].ToVal(z.t)
eval args[1] = frame[z.v2].ToVal(z.t2)
eval mgr.Enqueue(z.event_handler, std::move(args))

internal-op Event3
type VVV
op1-read
eval val_vec args(3)
eval args[0] = frame[z.v1].ToVal(z.t)
eval args[1] = frame[z.v2].ToVal(z.t2)
eval auto types = z.aux->types
eval args[2] = frame[z.v3].ToVal(types[2])
eval mgr.Enqueue(z.event_handler, std::move(args))

internal-op Event4
type VVVV
op1-read
eval val_vec args(4)
eval args[0] = frame[z.v1].ToVal(z.t)
eval args[1] = frame[z.v2].ToVal(z.t2)
eval auto types = z.aux->types
eval args[2] = frame[z.v3].ToVal(types[2])
eval args[3] = frame[z.v4].ToVal(types[3])
eval mgr.Enqueue(z.event_handler, std::move(args))


op Return
type X
eval ret_u = nullptr
eval pc = end_pc; continue

op Return
op1-read
type V
set-type $1
eval ret_u = &frame[z.v1]
eval ret_type = z.t
eval pc = end_pc; continue

op Return
type C
eval ret_u = &z.c
eval ret_type = z.t
eval pc = end_pc; continue


# Branch on the value of v1 using switch table v2, with default branch to v3
internal-op SwitchI
type VVV
op1-read
eval auto v = frame[z.v1].int_val
eval auto t = int_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval continue

internal-op SwitchU
op1-read
type VVV
eval auto v = frame[z.v1].uint_val
eval auto t = uint_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval continue

internal-op SwitchD
op1-read
type VVV
eval auto v = frame[z.v1].double_val
eval auto t = double_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval continue

internal-op SwitchS
op1-read
type VVV
eval auto vs = frame[z.v1].string_val->AsString()->Render()
eval std::string v(vs)
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval delete[] vs
eval continue

internal-op SwitchA
op1-read
type VVV
eval auto v = frame[z.v1].addr_val->AsAddr().AsString()
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval continue

internal-op SwitchN
op1-read
type VVV
eval auto v = frame[z.v1].subnet_val->AsSubNet().AsString()
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]
eval continue


internal-op Branch-If-Not-Type
op1-read
type VV
eval auto v = frame[z.v1].any_val
eval if ( ! can_cast_value_to_type(v, z.t.get()) ) { pc = z.v2; continue; }


internal-op Init-Table-Loop
type VV
eval auto ii = z.aux->iter_info
eval ii->tv = frame[z.v2].table_val
eval ii->loop_vals = ii->tv->AsTable()
eval ii->c = ii->loop_vals->InitForIteration()
eval ii->value_var_type = z.t
eval frame[z.v1].iter_info = ii

internal-op Next-Table-Iter
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval HashKey* k
eval auto ii = frame[z.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = z.v2; continue; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	auto t = ii->loop_var_types[i]
eval	auto& var = frame[ii->loop_vars[i]]
eval	if ( IsManagedType(t) ) DeleteManagedType(var)
eval	var = BuildVal(ind_lv_p, ii->loop_var_types[i])
eval }

internal-op Next-Table-Iter-No-Vars
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval auto ii = frame[z.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(ii->c)
eval if ( ! current_tev ) { pc = z.v2; continue; }

internal-op Next-Table-Iter-Val-Var
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval HashKey* k
eval auto ii = frame[z.v2].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = z.v3; continue; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval IntrusivePtr<Val> tev_p = {NewRef{}, current_tev->Value()}
eval auto val_var_t = ii->value_var_type
eval if ( z.is_managed ) DeleteManagedType(frame[z.v1])
eval frame[z.v1] = BuildVal(tev_p, val_var_t)
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	auto ind = ii->loop_vars[i]
eval	auto loop_var_t = ii->loop_var_types[i]
eval	if ( IsManagedType(loop_var_t) ) DeleteManagedType(frame[ind])
eval	frame[ind] = BuildVal(ind_lv_p, loop_var_t)
eval }

internal-op Next-Table-Iter-Val-Var-No-Vars
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval auto ii = frame[z.v2].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(ii->c)
eval if ( ! current_tev ) { pc = z.v3; continue; }
eval IntrusivePtr<Val> tev_p = {NewRef{}, current_tev->Value()}
eval auto val_var_t = ii->value_var_type
eval if ( z.is_managed ) DeleteManagedType(frame[z.v1])
eval frame[z.v1] = BuildVal(tev_p, val_var_t)

internal-op Init-Vector-Loop
type VV
eval auto ii = z.aux->iter_info
eval ii->vv = frame[z.v2].vector_val->RawVector()
eval ii->n = ii->vv->Size()
eval ii->iter = 0
eval frame[z.v1].iter_info = ii

internal-op Next-Vector-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval auto ii = frame[z.v2].iter_info
eval if ( ii->iter >= ii->n ) { pc = z.v3; continue; }
eval auto& vv = ii->vv->ConstVec()
eval if ( vv[ii->iter].IsNil(ii->yield_type) ) { ++ii->iter; --pc; break; }
eval frame[z.v1].uint_val = ii->iter
eval ++ii->iter

internal-op Init-String-Loop
type VV
eval auto ii = z.aux->iter_info
eval ii->s = frame[z.v2].string_val->AsString()
eval ii->iter = 0
eval ii->n = ii->s->Len()
eval frame[z.v1].iter_info = ii

internal-op Next-String-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval auto ii = frame[z.v2].iter_info
eval auto sval = ii->s
eval if ( ii->iter >= ii->n ) { pc = z.v3; continue; }
eval auto bytes = (const char*) sval->Bytes() + ii->iter
eval auto sv = new StringVal(1, bytes)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv
eval ++ii->iter

internal-op End-Loop
op1-read
type V
eval auto ii = frame[z.v1].iter_info
eval if ( ii->c ) ii->loop_vals->StopIteration(ii->c)
eval ii->c = nullptr
eval ii->vv = nullptr


op When
op1-read
type VVVV
eval auto when_body = new ResumptionAM(this, z.v2)
eval auto timeout_body = new ResumptionAM(this, z.v3)
eval new trigger::Trigger(z.e, when_body, timeout_body, frame[z.v1].double_val, f, z.v4, z.loc)

op When
type VVVC
eval auto when_body = new ResumptionAM(this, z.v1)
eval auto timeout_body = new ResumptionAM(this, z.v2)
eval new trigger::Trigger(z.e, when_body, timeout_body, z.c.double_val, f, z.v3, z.loc)

op When
type VV
eval auto when_body = new ResumptionAM(this, z.v2)
eval new trigger::Trigger(z.e, when_body, nullptr, -1.0, f, z.v1, z.loc)

op CheckAnyLen
op1-read
type Vi
eval auto v = frame[z.v1].list_val
eval if ( v->Vals()->length() != z.v2 ) ZAM_run_time_error(z.loc, "mismatch in list lengths")

op Print
type O
eval do_print(z.aux->ToValVec(frame))
method-post z.aux = v->aux

op Print1
op1-read
type V
set-type $1
eval std::vector<IntrusivePtr<Val>> vals
eval vals.push_back(frame[z.v1].ToVal(z.t))
eval do_print(vals)

op Print1
op1-read
type C
set-type $1
eval std::vector<IntrusivePtr<Val>> vals
eval vals.push_back(z.c.ToVal(z.t))
eval do_print(vals)


internal-op If-Else
op1-read
type VV
eval if ( ! frame[z.v1].int_val ) { pc = z.v2; continue; }

internal-op If
op1-read
type VV
eval if ( ! frame[z.v1].int_val ) { pc = z.v2; continue; }

internal-op If-Not
op1-read
type VV
eval if ( frame[z.v1].int_val ) { pc = z.v2; continue; }


op AddStmt
op1-read
type VO
eval auto index = z.aux->ToListVal(frame)
eval frame[z.v1].table_val->Assign(index.get(), nullptr)
method-post z.aux = v->aux

op AddStmt1
op1-read
set-type $2
type VV
eval auto index = frame[z.v2].ToVal(z.t)
eval frame[z.v1].table_val->Assign(index.get(), nullptr)

op AddStmt1
op1-read
type VC
eval auto index = z.c.ToVal(z.t)
eval frame[z.v1].table_val->Assign(index.get(), nullptr)


op DelTable
op1-read
type VO
eval auto index = z.aux->ToListVal(frame)
eval frame[z.v1].table_val->Delete(index.get())
method-post z.aux = v->aux

op DelField
op1-read
type Vi
eval frame[z.v1].record_val->RawFields()->DeleteField(z.v2)


internal-op Init-Record
type V
eval auto r = new RecordVal(z.t->AsRecordType())
eval Unref(frame[z.v1].record_val)
eval frame[z.v1].record_val = r

internal-op Init-Vector
type V
eval auto vt = z.t->AsVectorType()
eval auto yt = vt->YieldType()
eval auto vec = new VectorVal(vt)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec

internal-op Init-Table
type V
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, z.attrs}
eval auto t = new TableVal(tt, attrs)
eval Unref(frame[z.v1].table_val)
eval frame[z.v1].table_val = t


########################################
# Internal
########################################

op Sync-Globals
type X
eval for ( auto i = 0; i < num_globals; ++i ) {
eval	if ( global_state[i] == GS_DIRTY ) {
eval		auto id = globals[i].id
eval		auto slot = globals[i].slot
eval		auto t = id->Type()
eval		auto v = frame[slot].ToVal({NewRef{}, t})
eval		id->SetVal(v)
eval	}
eval	global_state[i] = GS_UNLOADED
eval }

op Dirty-Global
op1-internal
type V
eval global_state[z.v1] = GS_DIRTY

# These two are only needed for type-based switch statements.  Could think
# about replacing them using CoerceFromAnyExpr.
op Assign-Any
type VV
set-type $2
eval auto v = frame[z.v2].ToVal(z.t)
eval frame[z.v1].any_val = v.release()

op Assign-Any
type VC
set-type $2
eval auto v = z.c.ToVal(z.t)
eval frame[z.v1].any_val = v.release()

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval AssignV1(BuildVal(z.c.ToVal(z.t), z.t))

internal-assignment-op Load-Val
type VV
eval auto v = f->NthElement(z.v2)
eval @v

internal-assignment-op Load-Global
type VV
eval if ( global_state[z.v2] != GS_UNLOADED ) break
eval global_state[z.v2] = GS_CLEAN
eval auto v = z.aux->id_val->ID_Val()
eval if ( ! v ) { ZAM_run_time_error(z.loc, "value used but not set", z.aux->id_val); break; }
eval @v

# We need a special form here for loading global types, as they don't
# fit the usual template.
internal-op Load-Global-Type
type VV
eval if ( global_state[z.v2] != GS_UNLOADED ) break
eval global_state[z.v2] = GS_CLEAN
eval auto& v = frame[z.v1].type_val
eval Unref(v)
eval IntrusivePtr<BroType> t = {NewRef{}, z.aux->id_val->AsType()};
eval v = new TypeType(t)

internal-op Store-Val
op1-read
type VV
eval auto val = frame[z.v1].ToVal(z.t)
eval f->SetElement(z.v2, val.release())

### This now should work as just an ordinary Store-Val.
internal-op Store-Any-Val
op1-read
type VV
eval auto v = frame[z.v1].any_val->Ref()
eval f->SetElement(z.v2, v)

internal-op Copy-To
type VC
set-type $2
eval AssignV1(CopyVal(z.c))

internal-op GoTo
type V
eval pc = z.v1
eval continue

internal-op Hook-Break
type X
eval flow = FLOW_BREAK
eval pc = end_pc
eval continue


# Make sure that the given vector-of-any is either empty or in fact
# has the expected concrete internal type.
internal-op Check-Any-Vec
op1-read
type V
eval auto any_vec = frame[z.v1].vector_val->RawVector()
eval auto at = any_vec->YieldType()
eval if ( ! at ) break
eval if ( at->Tag() == TYPE_ANY && any_vec->ConstVec().size() > 0 ) reporter->InternalError("non-concrete vector-of-any")
eval if ( ! CheckAnyType(at.get(), z.t.get(), z.loc) ) ZAM_error = true

# Transform the given vector-of-any to a concrete internal type.
internal-op Transform-Any-Vec
op1-read-write
type V
eval auto any_vec = frame[z.v1].vector_val->RawVector()
eval auto at = any_vec->YieldType()
eval if ( ! at || at->Tag() == TYPE_ANY ) {
eval	if ( at && any_vec->ConstVec().size() > 0 ) reporter->InternalError("concretizing non-empty vector-of-any")
eval	any_vec->SetYieldType(z.t)
eval }

# Transform the given vector-of-any (v1) to be compatible with having one of
# its elements assigned to the dynamic type of the "any" value (v2).
internal-op Transform-Any-Vec2
op1-read-write
type VV
eval auto vt = frame[z.v2].any_val->Type()
eval auto any_vec = frame[z.v1].vector_val->RawVector()
eval auto at = any_vec->YieldType()
eval if ( ! at || at->Tag() == TYPE_ANY ) {
eval	if ( at && any_vec->ConstVec().size() > 0 ) reporter->InternalError("concretizing non-empty vector-of-any")
eval	any_vec->SetYieldType({NewRef{}, vt})
eval } else if ( ! same_type(at.get(), vt) ) {
eval	reporter->Error("inconsistent types for vector-of-any: %s vs. %s", type_name(at->Tag()), type_name(vt->Tag()))
eval	ZAM_error = true
eval }


########################################
# Built-in Functions
########################################

internal-op Sub-Bytes
type VVVV
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, frame[z.v3].uint_val, frame[z.v4].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVVi
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, frame[z.v3].uint_val, z.v4)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VViV
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, bro_uint_t(z.v4), frame[z.v3].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVii
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, bro_uint_t(z.v3), z.v4)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVVC
eval auto sv = ZAM_sub_bytes(z.c.string_val, frame[z.v2].uint_val, frame[z.v3].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VViC
eval auto sv = ZAM_sub_bytes(z.c.string_val, frame[z.v2].uint_val, z.v3)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type ViVC
eval auto sv = ZAM_sub_bytes(z.c.string_val, bro_uint_t(z.v3), frame[z.v2].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type ViiC
eval auto sv = ZAM_sub_bytes(z.c.string_val, bro_uint_t(z.v2), z.v3)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op To-Lower
type VV
eval auto sv = ZAM_to_lower(frame[z.v2].string_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

# A ZAM version of Log::__write.  In calls to it, the first argument
# is generally a constant (enum) *if we inlined*, but otherwise a
# parameter, so we support both VVV ad VVC.
#
# It's actually the case that the return value is pretty much always
# ignored ... plus optimization can elide it away.  See the second
# pair of built-ins for versions that discard the return value.
#
# Could speed things up further by modifying the Write method to just
# take the raw enum value, as it appears that that's all that's ever
# actually used.

internal-op Log-Write
side-effects
type VVV
eval auto id = frame[z.v2].ToVal(log_ID_enum_type)
eval auto columns = frame[z.v3].ToVal(z.t)
eval bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())
eval frame[z.v1].int_val = result

internal-op Log-WriteC
side-effects
type VV
eval auto id = z.aux->constants[0]
eval auto columns = frame[z.v2].ToVal(z.t)
eval bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())
eval frame[z.v1].int_val = result

# Versions that discard the return value.
internal-op Log-Write
side-effects
op1-read
type VV
eval auto id = frame[z.v1].ToVal(log_ID_enum_type)
eval auto columns = frame[z.v2].ToVal(z.t)
eval (void) log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())

internal-op Log-WriteC
side-effects
op1-read
type V
eval auto id = z.aux->constants[0]
eval auto columns = frame[z.v1].ToVal(z.t)
eval (void) log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())

internal-op Broker-Flush-Logs
side-effects
type V
eval frame[z.v1].uint_val = broker_mgr->FlushLogBuffers()

internal-op Broker-Flush-Logs
side-effects
type X
eval (void) broker_mgr->FlushLogBuffers()

internal-op Get-Port-Transport-Proto
type VV
eval auto mask = frame[z.v2].uint_val & PORT_SPACE_MASK
eval auto v = 0; /* TRANSPORT_UNKNOWN */
eval if ( mask == TCP_PORT_MASK ) v = 1
eval else if ( mask == UDP_PORT_MASK ) v = 2
eval else if ( mask == ICMP_PORT_MASK ) v = 3
eval frame[z.v1].uint_val = v

internal-op Network-Time
type V
eval frame[z.v1].double_val = network_time

internal-op Current-Time
type V
eval frame[z.v1].double_val = current_time()

internal-op Reading-Live-Traffic
type V
eval frame[z.v1].int_val = reading_live

internal-op Reading-Traces
type V
eval frame[z.v1].int_val = reading_traces

internal-op StrStr
type VVV
eval auto big = frame[z.v2].string_val
eval auto little = frame[z.v3].string_val
eval frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString())

internal-op StrStr
type VCV
eval auto big = z.c.string_val
eval auto little = frame[z.v2].string_val
eval frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString())

internal-op StrStr
type VVC
eval auto big = frame[z.v2].string_val
eval auto little = z.c.string_val
eval frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString())

internal-op Analyzer--Name
type VV
eval auto atype = frame[z.v2].ToVal(z.t)
eval auto& name = analyzer_mgr->GetComponentName(atype->AsEnumVal())
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(name)

internal-op Files--Enable-Reassembly
op1-read
type V
eval auto f = frame[z.v1].string_val->CheckString()
eval file_mgr->EnableReassembly(f)

internal-op Files--Set-Reassembly-Buffer
op1-read
type VV
eval auto f = frame[z.v1].string_val->CheckString()
eval file_mgr->SetReassemblyBuffer(f, frame[z.v2].uint_val)

internal-op Files--Set-Reassembly-Buffer
op1-read
type VC
eval auto f = frame[z.v1].string_val->CheckString()
eval file_mgr->SetReassemblyBuffer(f, bro_uint_t(z.v2))
